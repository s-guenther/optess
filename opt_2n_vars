#!/usr/bin/env python3
"""
This script sets up an optimization for the hybridisation problem
"""

import numpy as np
from numpy import array, linspace, zeros, shape, tile, ones
from numpy import concatenate as concat
import scipy.optimize as sciop

TIMES = linspace(0, 2 * np.pi, 12)
VALS = array(3 * [1, 0.5] + 3 * [-1, -0.5])

LENSIG = len(VALS)
AMP = max(np.abs(VALS))
CUT = 0.5


def objective_factory(times, lensig):
    """Factory that builds the energy function and objective function"""

    def minfcn(e_peak):
        return max(e_peak)

    def energy(power, time):
        return np.cumsum(power * np.diff(concat([[0], time])))

    def objective(x):
        return minfcn(energy(x[:lensig], times))

    return energy, objective


def main():
    """Stand alone execution"""

    # objective fcn
    energy, objective = objective_factory(TIMES, LENSIG)

    # init vector
    peak_init = zeros(shape(VALS))
    base_init = ones(shape(VALS))
    x0 = concat([peak_init, base_init])

    # constraints
    cons = []
    for ii in range(LENSIG):
        eqcon = {'type': 'eq',
                 'fun': lambda x: x[ii] + x[LENSIG + ii] - VALS[ii]}
        ineqcon1 = {'type': 'ineq',
                    'fun': lambda x: energy(x[:LENSIG], TIMES)[ii]}
        ineqcon2 = {'type': 'ineq',
                    'fun': lambda x: energy(x[LENSIG:], TIMES)[ii]}
        cons.append(eqcon)
        cons.append(ineqcon1)
        cons.append(ineqcon2)

    # bounds
    base_lim = AMP * CUT
    peak_lim = AMP * (1 - CUT)
    ub = concat([tile(peak_lim, LENSIG), tile(base_lim, LENSIG)])
    lb = -ub
    bnds = tuple(tup for tup in zip(lb, ub))

    # minimize
    return sciop.minimize(objective, x0, constraints=cons, bounds=bnds,
                          method='SLSQP')


if __name__ == '__main__':
    opt_res = main()
