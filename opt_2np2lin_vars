#!/usr/bin/env python3
"""
This script sets up an optimization for the hybridisation problem
"""

import numpy as np
from numpy import array, linspace, zeros, shape, tile, ones, cumsum, diff
from numpy import concatenate as concat
import scipy.optimize as sciop

VALS = array(3 * [1, 0.5] + 3 * [-1, -0.5])
TIMES = linspace(0, 2 * np.pi, 12)
DTIMES = concat([0], diff(TIMES))

LENSIG = len(VALS)
AMP = max(np.abs(VALS))
CUT = 0.5


def objective_factory():
    """Factory that builds the energy function and objective function"""
    def energy(power, dtime):
        return cumsum(power*dtime)

    def objective(x):
        return x[-2]

    return energy, objective


def main():
    """Stand alone execution"""

    # objective fcn
    energy, objective = objective_factory()

    # init vector
    peak_init = zeros(shape(VALS))
    base_init = ones(shape(VALS))
    esingle = max(energy(VALS, DTIMES))
    epeak = 0.3*esingle
    ebase = esingle - epeak
    x0 = concat([peak_init, base_init, epeak, ebase])

    # constraints
    cons = []
    for ii in range(LENSIG):
        # power equality constraints
        eqcon = {'type': 'eq',
                 'fun': lambda x: x[ii] + x[LENSIG + ii] - VALS[ii]}
        # peak energies < 0
        ineqcon1 = {'type': 'ineq',
                    'fun': lambda x: energy(x[:LENSIG], DTIMES)[ii]}
        # base energies < 0
        ineqcon2 = {'type': 'ineq',
                    'fun': lambda x: energy(x[LENSIG:], DTIMES)[ii]}
        # peak energies > epeak max
        ineqcon3 = {'type': 'ineq',
                    'fun': lambda x: x[-2] - energy(x[:LENSIG], DTIMES)[ii]}
        # base energies > ebase max
        ineqcon4 = {'type': 'ineq',
                    'fun': lambda x: x[-1] - energy(x[LENSIG:], DTIMES)[ii]}
        cons.append(eqcon)
        cons.append(ineqcon1)
        cons.append(ineqcon2)
        cons.append(ineqcon3)
        cons.append(ineqcon4)
    # energy capacity equality constraint: epeak + ebase = esingle
    cons.append({'type': 'eq',
                 'fun': lambda x: x[-2] + x[-1] - esingle})

    # bounds
    base_lim = AMP * CUT
    peak_lim = AMP * (1 - CUT)
    ub = concat([tile(peak_lim, LENSIG), tile(base_lim, LENSIG),
                 esingle, esingle])
    lb = -ub[:]
    lb[-2] = 0
    lb[-1] = 0
    bnds = tuple(tup for tup in zip(lb, ub))

    # minimize
    return sciop.minimize(objective, x0, constraints=cons, bounds=bnds,
                          method='SLSQP')


if __name__ == '__main__':
    opt_res = main()
